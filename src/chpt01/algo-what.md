# 什么是算法？

## 概念

对于算法的概念，有一个基本的共识：

**算法**（algorithm）是一系列解决问题的明确指令，即，针对符合一定规范的输入，能够在有限的时间内获得所要求的输出。

其中，“指令”需要能够被一定的主体所理解并执行，我们将这个主题称为“computer”，顾名思义，即“执行计算者”。现如今，这个主体一般指的是电子计算机。不过，算法的概念并不局限于计算机或者计算机程序。

## 算法的特点

算法有以下的特点：

- 算法的每个步骤都应无歧义；
- 需要确定算法所处理的输入的值域；
- 同一算法可以用若干不同的形式表述；
- 对于同一问题，可能存在若干种不同的算法。这些算法可能基于完全不同的解题思路，其所耗资源也往往不同。

一般来说，针对某个问题，没有算法在所有情况下都是最优的，往往需要根据情况选择最为合适的算法。

## 算法的表示

对于一个算法，我们可以用若干方式将其表示出来。

- 自然语言：适用性广，但往往较为冗长，有时不够严谨；
- 图表：如流程图；
- 伪代码：一种类似编程语言的方式，用其表示算法简洁、严谨；其定义可以参考 [Pseudocode - Wikipedia](https://en.wikipedia.org/wiki/Pseudocode)；
- 编程语言：（编译后）可以被计算机执行，但往往较为冗长，可读性与伪代码相比较差。

## 例：求最大公约数

下面以求最大公约数为例介绍算法。将两个不全为 0 的最大公约数记为 \\(\\gcd(m,n)\\)，即能够整除 \\(m\\) 和 \\(n\\) 的最大整数。

在中学时，我们学习过一种求解最大公约数的方法，如下：

1. 找到 \\(m\\) 的所有质因数；
1. 找到 \\(n\\) 的所有质因数；
1. 找出上述两步中分解得到的质因数序列重复出现的公因数；若某质因数分别在两个序列中出现了 \\(p\_m\\) 次和 \\(p\_n\\) 次，则该质因数在结果中应该出现 \\(\\min\\{p\_m,p\_n\\}\\) 次；
1. 将上一步中得到的质因数相乘，得到的数即为 \\(m\\) 和 \\(n\\) 的最大公约数。

这种方式很是熟悉，不过有个问题，就是没有明确定义“求解质因数”的方法，也没有具体说明如何找到两个列表中重复的质因数。

在古希腊数学家欧几里得的著作《几何原本》中介绍了一个求解最大公约数的算法，欧几里得算法（Euclid's algorithm）。用现在的数学语言来讲，即通过 \\(\\gcd(m,n) = \\gcd(n, m \\mod n)\\) 和 \\(\\gcd(m, 0) = 0\\) 这两个等式，就能得到结果。（\\(m \\mod n\\) 表示 \\(m\\) 除以 \\(n\\) 之后的余数）。

例如，\\(\\gcd(60,24)\\) 的计算过程如下：

\\[\\gcd(60,24) = \\gcd(24,12) = \\gcd(12,0) = 12 \\]

同样，我们可以用自然语言描述这个算法。对于 \\(m\\) 和 \\(n\\)，有如下的过程：

1. 如果 \\(n=0\\)，则返回 \\(m\\) 的值作为结果，过程结束；否则，进行下一步；
1. 将 \\(m\\) 除以 \\(n\\) 的余数记作 \\(r\\)；
1. 将 \\(n\\) 的值作为 \\(m\\)，将 \\(r\\) 的值作为 \\(n\\)，返回第一步，重复这个过程。

也可以使用伪代码描述这个算法：

```pseudo
Euclid(m, n)
  // 欧几里得算法计算 gcd(m, n)
  // 输入：两个不全为 0 的非负整数 m, n
  // 输出：m, n 的最大公约数
  while n ≠ 0 do
    r ← m mod n
    m ← n
    n ← r
  return m
```

对于欧几里得算法，有一个问题，就是我们如何得以确定其一定会终止，而不是一直处于循环之中呢？通过观察我们可以发现，经过每一次循环，两个算子中的后一个总会变得更小，且不会成为负数，而两个算子都为整数，因此我们可以确定经过若干次运算后，第二个算子的值会变为 0，算法结束。


